# -*- coding: utf-8 -*-
"""Handson-9.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mGfi9gCvvWd8Er_6S7ukRuw6h-VboZ5H
"""

class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, key, value):
        new_node = Node(key, value)
        if self.tail is None:  # Empty list
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def find(self, key):
        current = self.head
        while current is not None:
            if current.key == key:
                return current
            current = current.next
        return None

    def delete(self, key):
        node = self.find(key)
        if node is None:
            return False
        if node.prev:
            node.prev.next = node.next
        if node.next:
            node.next.prev = node.prev
        if node == self.head:
            self.head = node.next
        if node == self.tail:
            self.tail = node.prev
        return True

    def is_empty(self):
        return self.head is None

class HashTable:
    MULTIPLICATION_METHOD = 0
    DIVISION_METHOD = 1

    def __init__(self, size=8, method=DIVISION_METHOD):
        self.size = size
        self.count = 0
        self.method = method
        self.array = [DoublyLinkedList() for _ in range(size)]
        self.load_factor = 0.75

    def hash_division(self, key):
        return key % self.size

    def hash_multiplication(self, key):
        A = 0.6180339887  # A constant from Knuth
        return int(self.size * (key * A % 1))

    def hash(self, key):
        if self.method == self.MULTIPLICATION_METHOD:
            return self.hash_multiplication(key)
        else:
            return self.hash_division(key)

    def insert(self, key, value):
        index = self.hash(key)
        self.array[index].insert(key, value)
        self.count += 1

        if self.count / self.size >= self.load_factor:
            self.resize(self.size * 2)

    def search(self, key):
        index = self.hash(key)
        node = self.array[index].search(key)
        return node.value if node else None

    def delete(self, key):
        index = self.hash(key)
        node = self.array[index].search(key)
        if node:
            self.array[index].delete(node)
            self.count -= 1

            if self.size > 8 and self.count / self.size <= 0.25:
                self.resize(self.size // 2)

    def resize(self, new_size):
        old_array = self.array
        self.size = new_size
        self.array = [DoublyLinkedList() for _ in range(new_size)]
        self.count = 0

        for chain in old_array:
            current = chain.head
            while current:
                self.insert(current.key, current.value)
                current = current.next

# Step 1: Node and DoublyLinkedList definitions
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None

    def insert(self, key, value):
        new_node = Node(key, value)
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

    def search(self, key):
        current = self.head
        while current:
            if current.key == key:
                return current
            current = current.next
        return None

    def delete(self, node):
        if node is None:
            return
        if node == self.head:
            self.head = node.next
        if node.next:
            node.next.prev = node.prev
        if node.prev:
            node.prev.next = node.next

# Step 2: HashTable class
class HashTable:
    MULTIPLICATION_METHOD = 0
    DIVISION_METHOD = 1

    def __init__(self, size=8, method=DIVISION_METHOD):
        self.size = size
        self.count = 0
        self.method = method
        self.array = [DoublyLinkedList() for _ in range(size)]
        self.load_factor = 0.75

    def hash_division(self, key):
        return key % self.size

    def hash_multiplication(self, key):
        A = 0.6180339887  # A constant from Knuth
        return int(self.size * (key * A % 1))

    def hash(self, key):
        if self.method == self.MULTIPLICATION_METHOD:
            return self.hash_multiplication(key)
        else:
            return self.hash_division(key)

    def insert(self, key, value):
        index = self.hash(key)
        existing_node = self.array[index].search(key)

        # Update the value if the key already exists
        if existing_node:
            existing_node.value = value
        else:
            self.array[index].insert(key, value)
            self.count += 1

        # Resize if needed
        if self.count / self.size >= self.load_factor:
            self.resize(self.size * 2)

    def search(self, key):
        index = self.hash(key)
        node = self.array[index].search(key)
        return node.value if node else None

    def delete(self, key):
        index = self.hash(key)
        node = self.array[index].search(key)
        if node:
            self.array[index].delete(node)
            self.count -= 1

            # Resize if needed
            if self.size > 8 and self.count / self.size <= 0.25:
                self.resize(self.size // 2)

    def resize(self, new_size):
        old_array = self.array
        self.size = new_size
        self.array = [DoublyLinkedList() for _ in range(new_size)]
        self.count = 0

        for chain in old_array:
            current = chain.head
            while current:
                self.insert(current.key, current.value)
                current = current.next

# Step 3: Testing the HashTable class
if __name__ == "__main__":
    # Create a hash table with division method
    table = HashTable(size=8, method=HashTable.DIVISION_METHOD)

    # Insert key-value pairs
    print("Inserting elements...")
    table.insert(10, 100)
    table.insert(22, 200)
    table.insert(31, 300)
    table.insert(4, 400)

    # Search for elements
    print("\nSearching elements:")
    print(f"Search key 10: {table.search(10)}")  # Output: 100
    print(f"Search key 22: {table.search(22)}")  # Output: 200
    print(f"Search key 31: {table.search(31)}")  # Output: 300
    print(f"Search key 4: {table.search(4)}")    # Output: 400

    # Delete an element
    print("\nDeleting key 4...")
    table.delete(4)
    print(f"Search key 4 after deletion: {table.search(4)}")   # Output: None

    # Insert more elements to trigger resizing
    print("\nInserting more elements to trigger resizing...")
    for i in range(50, 55):
        table.insert(i, i * 10)

    # After inserting elements, check the size of the table
    print(f"\nCurrent table size after resizing: {table.size}")

    # Search for the newly inserted elements
    print("\nSearching newly inserted elements:")
    for i in range(50, 55):
        print(f"Search key {i}: {table.search(i)}")  # Should output corresponding values

    # Search for an element that was not inserted
    print(f"\nSearch key 99 (not inserted): {table.search(99)}")  # Output: None